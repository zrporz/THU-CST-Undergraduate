# CST 3-2 Report

## 算法构思

**位图数据结构设计：**本题最大的限制是6MB的空间，也就是只提供 $6\times2^{20}$ B大小的空间，而字符串长度要求需要能存$2^{24}$个数的空间，这就意味着不能用传统的int数组或bool的方式来存，于是自然想到了上课介绍的位图数据结构，这种数据结构将每个01字符存储在了一个bit里。这样成功将存储空间压缩到了$2^{21}$B的大小，从而满足题目对空间的要求。具体来说，是通过char数组的方式，以每个字符存储8个01字符的方式存储该字符串。

此外，在查询固定长度的子串时，由于一个字符某一固定长度的子串个数和这个字符长度几乎相同（准确来说只相差了一个子串长度），为了记住查询结果，我们同样需要一个规模和字符串大小相同的01字符串，而这个字符串的存储又可以通过一个位图实例来实现。

因此，该算法用到了两个位图实例，第一个位图实例`b`负责存储字符串，第二个位图`found`负责存储针对某一特定位数，符合这种长度的01串是否出现在字符串中，具体来说，第 i 位存储的是原字符串中是否存在 i 二进制形式下的子串。

**针对某一特定长度k，查找是否存在NotFound子串:** 在之前的位图设计中已经说明了`found`实例的含义，接下来还需要特别说明的是如何更高效的实现在原串中检索所有子串。首先，注意到如果线性扫描子串的话，每次扫到的子串和前一个子串相比只要首尾两个字符不同，这就意味着不用每次都把子串转化为十进制数，而是可以通过首尾数字对上一个子串对应的十进制数进行适当的运算转换成下一个子串对应的十进制数。此外，线性扫描时，设置`num`变量来记录发现了多少个不同的子串，可以稍稍提高之后寻找最小字典序的子串的效率。

**通过二分查找来优化搜索效率：**由于字符串长度限制在$2^{24}$范围内，这就意味着，NotFound子串长度不能超过24，也就是说我们最终找到的这个NotFound子串长度确定在$[1,24]$内，而我们需要找的是满足在原串中找不到该子串，且该子串在所有NotFound子串中长度和字典序最小，于是便可以通过二分查找的方式优化时间效率。

具体来说，算法针对特定子串长度k，通过函数`see(k)`来判断是否存在NotFound子串，并在`res`中保存该所有该长度且不存在在原字符串的子串中字典序最小的那个，如果返回值为`true`，即找到了较小子串，下一次查找的范围就在`[lo,k)`之间，否则就在$[mid+1,hi)$之间（$lo和hi初始为1和25$）

## 时间和空间复杂度的估算

**时间复杂度：**根据上一节对算法的描述，位图的赋值和循秩访问都是$O(1)$时间的，因此字符串读入时间为$O(n)$。此外，针对特定一子串长度的查询，需要多次线性扫描，因此时间复杂度为$O(n)$而子串长度在$[1,logn]$之间，通过二分查找优化，需要查找$O(log(logn))$次，因此总查询时长的时间复杂度为$O(nlog(logn))$。

综上，总时间复杂度为$O(nlog(logn)) n=2^{24}$

**空间复杂度：**每个位图实例都需要开一个char数组，其大小正比于字符串长度，相比一个char存一个字符来说现在一个char可以存8个字符，空间复杂度为$O(n/8)$，消去常数后是$O(n)$，除此以外程序没有其它的大开销，因此总的空间复杂度就是$O(n)$