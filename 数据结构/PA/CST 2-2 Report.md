# CST 2-2 Report

## 算法构思

本题的实现思路主要参考教材中中缀表达式的算法。大体思想为：从左向右依次扫描一个每个字符，如果读到的是操作数则加入操作数栈，如果是操作符则需要比较和操作符栈栈顶的优先级关系，如果栈顶优先级更高则计算栈中两个操作数（本题中除括号外全部都是双目运算符），如果当前操作符优先级更高则入栈，如果相当则去掉栈顶操作符，并读取下一个位置的字符（对应去括号和\0匹配）。

为了完成本题我构造了两个类，`Stack`和`Poly`，前者用数组模拟了一个简单的栈结构，后者建立了一个多项式类实现其各项系数的存储以及加减乘次方运算。

具体实现时本题和教材也有一些不同：

1. 本题中操作数是一位位读入，且含有x，因此我设置了`tmp_num`变量来记录多位数，并且考虑x的情况。只有当读入下一个字符时才能知道之前的操作数读入是否结束，此时才将此前的操作数转化成Poly对象后入栈，这也是和教材不太一样的地方。
2. 乘号省略。根据题目描述，乘号省略包括“)(，n(，x(，nx，)x”（n表示数字）这5种情况，所以每次读入字符时会判断一下这个字符和其前一个字符是否满足乘号省略的条件，如果满足则相当于先要让乘法和栈顶操作符比较，运算或入栈后再次读取当前字符（我使用一个`mul`变量来记录“读入当前字符时是否已经考虑乘号被省略”，从而确定是补乘号还是真正读取当前字符）
3. 取模运算，每次运算后都要对1000000007取模，对于负数x，我采用$(x+1000000007)\mod1000000007$的方法

一些算法优化：

1. 在读入字符串时，考虑到\^1这个运算本身对运算结果没有影响，为了避免不必要的次方运算，省略了所有\^1
2. 每当构造一个多项式类时，都会用一个`_degree`变量来记录这个多项式类实例的最高位幂次，这样在乘法运算时不需要循环64\*64次而只需要循环`_degree1`\*`_degree2`次

## 时间和空间复杂度的估算

**时间复杂度：**程序时间复杂度主要来自三部分：字符串读入和出入栈计算。字符串读入显然是$O(n)$的，下面针对出入栈计算的时间复杂度进行分析。

每当扫描到一个字符，程序会判断此时运算数入栈（这里的运算数实际上是这个字符之前的字符组成的，比如123\*x当扫描到\*时123入栈）、运算符入栈或继续扫描，这个判断是线性的。计算时程序开了运算数和运算符两个栈，字符串中每个字符至多入其中一个栈一次并出栈一次（考虑到有些字符会整体作为一个数字入运算数栈，实际上出入栈的是运算数和运算符，其总和是小于字符串长度的）。此外，考虑到乘号省略情况，补全乘号后的字符串总长度也一定不会超过2n，最坏情况下也是线性的。运算数和运算符出栈时进行计算，每次计算的复杂的为常数次，因此总复杂度可以视作为 $O(n)$

综上所述，算法的时间复杂度为$O(n)$

**空间复杂度：**每个栈均需开一个长为1000010的数组，共开两个栈，运算符栈每个元素的大小为char类型大小，运算数栈每个元素为一个Poly类，每个Poly类实例占空间大小主要为长为65的int数组，因此两个栈空间复杂度都可以视为$O(n)$。此外程序还开了一个长为1000010的字符串来存储中缀表达式。因此总空间复杂度为 $O(n)$