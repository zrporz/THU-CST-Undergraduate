# CST 4-2 Report

## 算法构思

本题所要完成的任务和Dijkstra算法相似，都是求从起点到终点的最短距离，不同之处在于权重由边转移到了点，但这并不会对算法本身造成过大的改动；另一个不同是本题要求还要求出最短路径的数量，这需要我们基于Dijkstra算法进行改进。此外，如果使用蛮力Dijkstra算法的话时间复杂度为$O(n^2)$代入n简单计算便可知会导致超时，因此我们需要设计一种数据结构，能够返回当前非永久性节点中路径长度最小的结点，避免$O(n)$的轮询，优先级二叉堆可以满足我们的这一需求。

#### 建图过程

每个游戏关卡存储为一个`Node`结点，每个结构体中存有以下成员变量：

- `minlen`：从起点开始，到结点的最短长度
- `num`：到结点的最短路径的数量
- `time`：通过结点所需的用时
- `flag`：标记结点是否为永久结点

边的信息保存在`Edge e`数组中，本题中每条边都是一条无向边，我们将其转化为两条方向相反的边，这样便于建立以起始点为索引的链表，链表表头存储在数组`head`中。

#### 设计优先级二叉堆

二叉堆中每一个结点`PQNode`存储两个变量：

- `id`：记录这个点对应结点的id值
- `num`：记录**在结点插入时**，到达该结点的最短路径

二叉堆堆顶的元素满足，堆顶的结点的`num`值为全堆最小。

每当插入一个`PQNode`结点时，我们将其添加在当前堆的末尾，然后根据其`num`值”上浮“。删除一个`PQNode`结点时，我们首先记录堆顶的值，然后将其和堆尾元素交换，随后让堆顶元素”下沉“。这些都是二叉堆的基本操作。

#### Dijkstra算法：初始化

一开始，将起点的最短路大小赋为该关卡的耗时，将其添加到堆中，并将起点设为工作结点

#### Dijkstra算法：过程

每次确定一个工作结点后，将其变为永久结点，并更新所有和它相邻的非永久性结点的最短路径值和最短路径数量，对于工作结点p和其相邻结点q，更新规则如下：

- $minlen(p)+time(q)>minlen(q)$，保持q的最短路径距离和最短路径数不变
- $minlen(p)+time(q)=minlen(q)$，q的最短路径距离不变，最短路径数在原有基础上加上$num(q)$
- $minlen(p)+time(q)<minlen(q)$，q的最短路径距离更新为$minlen(p)+time(q)$，最短路径数更新为$num(q)$

这样就实现了同时记录最短路径长度和最短路径数。

将所有相邻结点更新完后，从优先级二叉堆中不断取出堆顶元素p，直到取出的p表示的是一个现在为非永久节点为止，此时的p一定是所有非永久结点中最短路径距离最小的结点。将p确定新的工作结点，重复上述过程，直到终点变为永久结点为止。

## 时间和空间复杂度的估算

**时间复杂度：**由于每条边至多只有一个方向上的结点会被插入到二叉堆中，所以二叉堆结点数至多为m，二叉堆的插入和删除操作时间复杂度均正比于其树高，也就是$O(log(m))$，由于每条无向边至多会插入一次，因此插入的总时间复杂度为$O(mlog(m))$，删除也是同理，每次取出的堆顶元素不一定就是我们需要的那个结点，可能某次寻找工作结点时需要多次取出堆顶元素，但取出的总元素个数不会大于堆中最大元素个数，因此取出操作的时间复杂度上界应该也是$O(mlog(m))$。因此，算法的时间复杂度为$O(mlog(m))$

除此以外，对结点和边的读入操作其复杂度为$O(n)$和$O(m)$，考虑题目并没有给出m和n的大小关系，但m和n具有相同的量级，因此总的时间复杂度也可以写作$O((m+n)log(m))$，这样写可以涵盖n很大但m很小的情况。

**空间复杂度：**存储边的数组和二叉堆数组空间复杂度均为$O(m)$（这两个数组我都开到了2m的大小，实际上二叉堆数组大小开到m已经足够），存储邻接表表头的的数组和关卡结点数组的空间复杂度均为$O(n)$，因此，总的空间复杂度为$O(m+n)$

