# CST 3-5 Report

做完 CST 3-6 最近邻查找后，本以为手握KD树模板，这道题会完成得比较快，但事实证明不同的问题中kdtree差异还是很大的，为此花了不少时间来改进原树模板。

## 算法构思

#### KD-Tree构造方法

##### 结点

KD-Tree每个结点存储以下信息：

`l`,`r`：左右孩子下标

`num[2]`：该结点所表示点的坐标

`dim`：该结点所“切”的维度，$dim\in[0,d)$

`up_bond[2],low_bond[2]`：每一个结点都代表在2维空间的矩形中“切”了一刀，这两个数组表示的就是这个矩形的上下界。对于每一个结点点，我们规定其上下界为这个结点表示区域包含的所有结点的上下确界，特别的，如果只有一个结点，那么其上下确界就是自己的坐标。

`max_temp,min_temp`:该结点表示区域内的最高气温和最低气温。

##### 建立KD-Tree

原始结点被输入后存储在数组`node`中，我们用函数`build(lp,rp,d0)`递归地建立KD-Tree，对每一个递归实例：

1. 将`node`数组中下标处于$[lp,rp]$之间的部分进行升序排序，排序依据是其第d0维的坐标大小($d0=0 , 1$)
2. 对区间进行线性扫描，确定空间坐标的上下确界，更新`up_bond[2],low_bond[2]`
3. 找到排序后区间内中位数的结点，用该结点的坐标来构造一个KD-Tree中的结点，并将该结点保存在`kdtree[index]`中
4. 递归$[lp,rp]$的左半部分和右半部分（构造时需要判定左右区间是否为空，如果为空则不需要再为其建立子结点，此时其子结点下标指向0，也可视作空结点或垃圾结点），递归构造`kdtree[index]`的左右子树，最后更新其区域内温度最大值和最小值。

**区间内的温度最值查找：**

我们设计了`query_p`函数来递归地查找结点p表示的区域和给定查找区间的交集，并更新查找到的气温最大值和最小值，对于每个结点分为以下四种情况讨论：

1. 到达空结点，则直接返回，不做更新操作
2. 结点表示区域包含于查找区间，则直接根据这个结点标记的气温最大值和最小值更新查找结果，不需要再深探
3. 结点表示区域与查找区间完全无交集，则直接返回不做更新操作
4. 结点表示区域与查找区域存在交集，则首先根据这个结点表示站点的温度最大值和最小值更新查找结果，然后对其左右子树进行深探。

在实际写代码的时候，我们采取比较两个维度来确定查找区间和结点区间的关系，这是和讲义中KD树区间查询不同的地方，但显然这个剪枝要比比较单维度更强，实际运行的时候效果也更好。

## 时间和空间复杂度的估算

##### 时间复杂度

本题的时间消耗来自两步操作：建立KD-Tree和对KD-Tree的查找，下面分别对其进行分析。

建立KD-Tree的时间复杂度可以这样分析：考虑一颗满树，其深度为k的层有$2^k$个结点，也就对应在递归建立是要创建$2^k$个递归实例，对于每一个递归实例，其包含的区间长度为$len \leq \frac {n}{2^{k}}$，每一个递归实例中，时间复杂度主要来自区间排序，其复杂度为$O(lenlog(len))$而每一层总的时间复杂度应为$O(lenlog(len) \cdot 2^k) = O(n(logn-k)) k=1,2,… logn$。KD-Tree共有$logn$层，因此总的时间复杂度为$O(n(logn)^2)$。

对KD-Tree的每次区间查找，根据讲义中对KD树查询的时间复杂度分析，由于每两刀最多切到2个矩形，因此复杂度递推式满足$Q(n)=2Q(n/4)+O(1)$，因此其复杂度为$O(\sqrt n)$（讲义中的问题是记录具体的所有点，因此还要加上report的复杂度r，但本题只获取区间最值，更新次数应正比于区间包含的矩形框个数，对于完全包含于区间的矩形框，不需要深究其内部的每个点，因而不需要加r）。

综上，结合这两步操作，总的时间复杂度为$O(n(logn)^2+m\sqrt n)$

##### 空间复杂度

KD-Tree存储在数组`kdtree`中，每个结点的struct需要存储12个int，数组空间消耗为$O(n)$，原始结点存储在二维`node`数组中，其大小也为$O(n)$，建树的递归实例个数应等于KD树的结点个数，节点个数不大于2n，递归建树空间复杂度为$O(n)$，查询递归的递归实例个数应等于访问结点的个数$O(log(n))$。

因此，总的空间复杂度为$O(n+log(n)) = O(n)$
