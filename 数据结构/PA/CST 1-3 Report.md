# CST 1-3 Report

## 算法构思

因为“插入字符”和“删除字符”操作实际上是可以交换顺序的，所以每种从A到B之间的变换，实际上都可以转换成从A删除字符到A和B的某个公共子序列，然后再插入字符直到得到B。要求k步内能否从A变成B，实际上就是用动态规划方法求A和B最长公共子序列的问题。

## 实现过程中遇到的问题

具体实现时需要解决以下几个问题：1.由于500000\*500000会超过存储空间范围，查询网络后发现可以采用滚动数组方法，转换为2\*500000大小的数组。2.使用一般的求公共子序列算法会超时，但考虑到k步的限制，所以每次不需要枚举500000次，而只需要看$((n > m ? n - m : m - n) + k) / 2 + 1$范围内即可（相当于只用看对角线附近的）。

## 时间和空间复杂度的估算

**时间复杂度：**DP是算法的关键，时间复杂度为$O(kn)$（不妨令n>m，$n\leq501000$）

**空间复杂度：**主要占用空间的为memo数组，大小为2\*501010，和两个长为501000的char数组，因此算法空间复杂度为$O(n)$