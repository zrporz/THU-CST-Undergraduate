# LAB1 Zuma Report

## 01

**错误类型**

Runtime Error

**错误原因**

第19行

```c++
play(left - 1);
```

未考虑到如果left本身变为0的时候left-1小于0的情况，即某种操作使从最首字符开始到操作位置之间的字符都被消掉，即会触发该错误

**测例构造**

相应测例：

```
AABBAB
1
2 B
```

标准答案：

```
B
```

构造思路：只需要构造某种操作使从首字符开始到操作位置之间的字符都被消掉的情况即可。上例中，当执行第一次消除后，程序运行到第19行时`left=0`此时会调用函数`play(- 1)`，而执行到第十行`a.at(rank);`此时`rank=-1`会导致函数访问数组错误，导致RE。

## 02

**错误类型**

Runtime Error

**错误原因**

未考虑到字符串被消除为空串后`a.at(0)`会越界访问

**测例构造**

相应测例：

```
AABBAA
1
2 B
```

标准答案：

```
（空串）
```

构造思路：只需要构造某种操作使字符完全被消除，得到空串即可。此时完全消除字符串后变量`next`=0，函数调用`play(0)`，在下一个实例中，第十行调用`at(0)`时会导致数组越界访问

## 03

**错误类型**

Time Limit Exceeded

**错误原因**

该算法中用到的`erase`和`insert`方法的时间复杂度均是$O(n)$，最坏情况下，整体复杂度为$O(mn)$，效率过低会导致超时问题

**测例构造**

相应测例：

```
AABBCCDDEEFFGGHHIIJJKKLLMMNNOOQQPPRRSSTTUUVVWWXXYYZZ……
500000
0 A
0 B
……
```

标准答案：

```
UUVVWWXXYYZZAABBCC……
```

构造思路：使n和m均达到数据大小上限，并且每一次操作都有一定的复杂度（比如让每次操作都消除一些字符串）便会导致超时。

## 04

**错误类型**

Wrong Answer

**错误原因**

代码第12行

```c++
while (left > 0 && a.at(left) == color) --left;
```

操作时由于left未加1导致每次删除的字符串左侧会多删除一个，因此导致错误结果

**测例构造**

相应测例：

```
ABBC
1
1 B
```

标准答案：

```
AC
```

构造思路：构造一个待删除串左侧有不应该被删除的字符即可，上例中A就会被错误删除，消除时left=0，right=3，则`erase(left, size)`会删除字符串ABB，导致WA。

## 05

**错误类型**

Wrong Answer

**错误原因**

代码第27行

```c++
cin >> a;
```

输入字符串时用的`cin`而非`getline`，无法读入空字符串，不满足输入要求

**测例构造**

相应测例：

```

1
0 A
```

标准答案：

```
A
```

构造思路：构造一个空串即可制造错误，`cin>>a`无法读入。

## 06

**错误类型**

Wrong Answer

**错误原因**

当某一块输入大于$2^{12}$时，程序没有进行重组块操作，溢出的数据可能覆盖后面的块

**测例构造**

相应测例：

```
ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ……
2049
1 A
1 B
1 C
1 D
1 E
1 F
1 G
1 H
……
```

标准答案：

```
AUTSRQPONMLKJIHGFEDCBA……
```

构造思路：构造一个使某一块长度大于$2^{12}$的操作即可使块数据溢出，上例中，会不断向位置1处添加字符且不会发生消除，在添加$2^{11}$个后，`p[0]`中元素已满，此时再在第0块中添加一个字符且不可消去时，`p[0]`溢出覆盖后面的内存，导致错误结果

## 07

**错误类型**

Wrong Answer

**错误原因**

第96行

```c++
if (l.second < 0 && l.first >= 0)
```

应改为while循环，否则会导致当某次消除需要跳过一个已经为空的块儿时无法跳过（if仅使`l.first`减了一次）

**测例构造**

相应测例：

```c++
CAABBAABB……AAD（第一块）AABB……AABB （第二块）DE
2048
1 A
1 B
1 A
1 B
……
2 A
2 B
2 A
2 B
……
2 D
```

标准答案：

```
CE
```

构造思路：构造一个消除操作恰好要越过一个空块儿的测例即可，算法无法越过空快向前读取重复的字符，比如上例中，在最后一个D输入前，字符串会消除为“CD(第一块)（第二块为空）DE（第三块），此时在2处插入D，此时执行第96行时，程序无法从第三块跨过第二块看到第一块中的D，从而无法将D连消，导致产生CDDDE这样的错误结果

## 08

**错误类型**

Wrong Answer

**错误原因**

第92行处未进行while(1)操作，会导致无法连续消除

**测例构造**

相应测例：

```c++
AABBAA
1
2 B
```

标准答案：

```
（空串）
```

构造思路：构造一个会发生连续消除的样例即可

## 09

**错误类型**

Runtime Error

**错误原因**

第130行处未判定`l.first`和`r.first`是否相等，可能出现两个相等即删除的字符串但没有跨越块儿的情况，这时候plen可能会记录错误的块长度大小数据，从而在`p2a`函数中` memcpy`函数移动数组时产生访问越界的问题

**测例构造**

相应测例：

```c++
AABBCC
1
2 B
```

标准答案：

```
AACC
```

构造思路：构造一个消除只发生在一个块内，且消除字符串的前后都有需要被保留的字符串即可，这样就会导致plen记录了错误的长度大小（负值），本例中，`l.second`=1,`r.seconde`=5,由于`l.first`与`r.first`相等，因此第135行计算出的`len`为-3，而赋到`size_t`类型的plen[0]中时会被转换成大整数18446744073709551613这样一个很大很大的数，远远大于p[i]的大小（$2^{12}$），导致在函数`p2a`中执行 `memcpy`时，将一个取了大于p[i]大小的数组内容，这就产生了了数组越界。

## 10

**错误类型**

Wrong Answer

**错误原因**

第147行

```c++
 for (int i = l.first; i < r.first; i++)
     plen[i] = 0;
```

i从`l.first`开始，并将其长度置为0，实际上第i块长度并不一定达到零，这就会导致最后在`p2a`组装回去中各块出现长度不对应的情况，在a长度计算正确的情况下，会导致组装错误

**测例构造**

相应测例：

```c++
BAABBAABB……AABBC
1
2048 B
```

标准答案：

```
BAABBAABB……AAC
```

构造思路：构造一个消除会跨越块发生，且消除字符的前后都有剩余字符的测例即可。本例中，数组总长计算没有错，但`plen[0]`会被赋成0，所以导致`p2a`中第一块部分并没有被组装回原数组a中，只有`p[1]`中剩余的“C”会被复制到a[0]开始的内存中，而后面的部分实际上是a数组原来的剩余，最终导致输出C（来自`p[1]`）AABBAABB……（原数组剩余）的结果，产生错误答案

