# CST 3-4-2 Report

## 算法构思

#### 线段树动态创建结点

根据提示，本题考察的是线段树这一数据结构，但由于n数据范围较大（$n<2^{31})$，将完整线段树建出来所需要的空间成本过高（完整建出整棵树的空间复杂度是$O(n)$）。而另一方面，查询/插入区间操作的次数m比较有限（$m<2\times 10^{5}$），实际上并不会真正用到每一个节点，尤其是一些靠近树叶的节点的信息，因此我们需要使线段树创立结点动态化，即不是在一开始就将线段树完整的建出来，而是”随用随建“，只有当操作需要读取/改变某个节点的儿子节点的信息时才将其儿子节点建立，从而起到减少空间占用的效果。

具体来说，如讲义634页所展示，每次翻盘/查询操作所访问到的节点可以构成一棵二叉树，而这棵二叉树又只有$O(log(n))$个叶节点（一个线段被分成两半，左半部分每层至多一个右子树作为叶节点，右半部分同理），根据二叉树性质，二叉树的非叶节点数=叶节点数-1,所以整个二叉树的节点个数也是$O(log(n))$的，因此m次操作，至多会访问到$O(mlog(n))$个节点，并不会访问所以节点。最终，根据本题数据范围和空间限制，我选择将存储节点的数组开到$10^6$大小。

#### 函数设计

**懒惰标记：**对于每一个节点，我为其设计了懒惰标记：懒惰标记lazy的值表示该节点表示的区间内，除了sum记录的翻牌次数外，该节点下的每个节点还会被翻lazy次，这样当翻盘时遇到某一结点表示的区间完全包含于操作区间时，只需要为其懒惰标记加1即可，而不需要递归其子树

**`push_down`: ** 当操作需要访问某个节点的子节点时，首先需要尝试为其创建子节点，然后再将懒惰标记下放，并将该节点的sum值更新。

**`merge_up`: **用于翻牌操作，但对某节点的子节点进行翻牌操作后，此时子节点的sum变为修改后的值，需要根据左右子节点的sum值更新父节点的sum，从而使父节点sum值记录修改后的结果

**翻牌：**用递归函数的方式实现，针对某一结点，对其$[l,r]$子区间进行翻牌操作，会有四种情况：1.$[l,r]$恰好就是这个节点表示的区间，则修改其懒惰标记后返回。2.$[l,r]$仅包含于左子树，则递归其左子树。3.$[l,r]$仅包含于右子树，则递归右子树。4.$[l,r]$既包含于左子树，又包含于右子树。对于后三种情况，需要同时递归两棵子树，并在递归后将两侧结果`merge_up`赋给父节点。

**查询：**设计思路和翻牌类似，不同在于查询相当于”只读“，并不会真正修改sum的大小（但依然会有懒惰标记下放的情况，比如所查询的区间设计了新节点的建立），所以在情况1中只需要返回其sum值，而情况4中不再需要`merge`

#### 常数优化

为了将节点数组开的尽量大，我尽可能缩小了每个节点的大小，最后每个Node类只有3个int和1个long long，这样就可以使存储节点的数组开到$10^6$大小。

## 时间和空间复杂度的估算

**时间复杂度：**如前文”线段树动态创建结点“一节所述，每次翻牌/查询操作，至多访问到$O(log(n))$个节点，而对每个节点操作的时间复杂度为$O(1)$，共进行m次这样的操作，所以总的时间复杂度为$O(mlog(n))$

**空间复杂度：**如前文”线段树动态创建结点“一节所述，只需要$O(mlog(n))$个节点就可以满足m次操作访问节点的需求。而每个节点的空间复杂度为$O(1)$，因此总的空间复杂度为$O(mlog(n))$（在程序中我开到了$10^6$）