# CST 3-6 Report

## 算法构思

#### KD-Tree构造方法

##### 结点

KD-Tree每个结点存储以下信息：

`l`,`r`：左右孩子下标

`num[5]`：该结点所表示点的坐标

`dim`：该结点所“切”的维度，$dim\in[0,d)$

`up_bond[5],low_bond[5]`：每一个结点都代表在d维空间($2\leq d \leq5$)的高维立方体中“切”了一刀，这两个数组表示的就是这个“**高维立方体**”的上下界。对于根节点，我们将其上下界设为$\pm MAX$，其大小为$10^7$(因为题目规定每一个向量坐标不会超过这一区域，所以MAX起到代替$\infty$的作用)

为每个结点设置上下界的目的是，在查找最近邻时，能通过查询结点到某个一个结点所处的空间立方体的距离，判断是否需要剪枝（query节中进一步介绍）

##### 建立KD-Tree

原始结点被输入后存储在数组`node`中，我们用函数`build(lp,rp,d0)`递归地建立KD-Tree，对每一个递归实例：

1. 将`node`数组中下标处于$[lp,rp]$之间的部分进行升序排序，排序依据是其第d0维的坐标大小
2. 找到排序后区间内中位数的结点，用该结点的坐标来构造一个KD-Tree中的结点，并将该结点保存在`kdtree[index]`中
3. 递归$[lp,rp]$的左半部分和右半部分（构造时需要判定左右区间是否为空，如果为空则不需要再为其建立子结点，此时其子结点下标指向0，也可视作空结点或垃圾结点），构造`kdtree[index]`的左右子树，同时更新其对应区域的上下界。

**查找最近邻结点：**

每次查找某个结点q的最近邻时，用`min_len`记录最短距离，首先在KD-Tree中不断深探找到“离q最近”的叶节点，但这个“离q最近”是打引号的，正如KD-Tree的区间查找算法一样，由于每个结点的具体位置并不确定，所以深探找到的叶节点未必就是真正离q最近的结点。此时需要自下而上班地回溯深探过程中经过的所有结点，对于每一个路径上的非叶结点，首先应判断此结点**距离q是否更近**并更新`min_len`。此外，如果该结点的另一棵子树可能存在一个距离q比当前最短距离更短的结点。则需要对另一棵子树进行搜索，重复此操作，直至回溯至根节点。

那么如何判定一个结点的另一棵子树是否可能存在距离q最近的结点呢？我们给出两种剪枝方法：

1. 判断该结点对应的维度上，结点和q距离的平方是否小于`min_len`，实际上这一操作是求了q到这一边界的垂直距离，若小于，则需要搜索另一子树。
2. 判断该结点另一个儿子对应的“高维立方体”p和q的距离，运算公式为$\Sigma_{i=0}^{d-1}(len(q,p,i))^2$，其中$len(q,p,i)$表示在第i维上q到高维立方体p的距离，显然当$q[i]\in[p.low\_bond[i],p.up\_bond[i]]$时，该维度的距离为0。若这一距离小于了`min_len`则有必要对其进行深探。

显然第一种剪枝方法是弱于第二种剪枝方法的，但程序中实际上同时用了两种剪枝方法，原因是计算多维距离的平方这一操作虽然能够跟多的剪枝，但计算本身却要花费比方法一更多的时间。因此，我们采用了先用方法一粗判剪枝，再用方法二进一步细判的方法，提高剪枝效率。

## 时间和空间复杂度的估算

##### 时间复杂度

本题的时间消耗来自两步操作：建立KD-Tree和对KD-Tree的查找，下面分别对其进行分析。

建立KD-Tree的时间复杂度可以这样分析：考虑一颗满树，其深度为k的层有$2^k$个结点，也就对应在递归建立是要创建$2^k$个递归实例，对于每一个递归实例，其包含的区间长度为$len \leq \frac {n}{2^{k}}$，每一个递归实例中，时间复杂度主要来自区间排序，其复杂度为$O(lenlog(len))$而每一层总的时间复杂度应为$O(lenlog(len) \cdot 2^k) = O(n(logn-k)) k=1,2,… logn$。KD-Tree共有$logn$层，因此总的时间复杂度为$O(n(logn)^2)$。

对KD-Tree的每次查找，上网查询得知在点随机均匀分布的情况下其时间复杂度为$O(logn)$，但因为个人能力有限，无法对一般情况进行证明，下面仅在一个特别情况，即所有点都严格均匀分布的情况下证明其复杂度。

可以这样考虑，对KD-Tree的每次查找，首先要深探至叶节点，其复杂度为$O(logn)$，将整个d维空间平均划分为边长为$\frac{a}{n^{1/d}}$的n个d维立方体，由于每个向量分布是均匀的，因此每个立方体内仅存在结点，深探所确定的叶结点与目标结点q之间的的距离，应不大于d维立方体体对角线的长度$L = \sqrt d\cdot a\cdot n^{-1/d}$，因为高维球体体积不太方便计算，下面考虑以$2L$为边长，q为中心做高维立方体$M$，球真包含于该立方体中，任何在该立方体之外的高维立方体和q的距离应大于$L$，而根据此前对每个立方体内结点只有1个的条件，$M$内所包含的结点个数肯定不会超过$2^dd^{d/2}$，因此获取他们中长度最小值的时间复杂度为$O(2^dd^{d/2})$，由于$d\leq5$，可以认为这个复杂度是$O(1)$的

因此，对于q次查找，其时间复杂度为$O(q(logn))$

因此，总的时间复杂度为$O(n(logn)^2+qlogn) \ n \leq 10^5, q \leq 2 \cdot10^5 \ d\leq5, \ n \leq 10^5, q \leq 2 \cdot10^5$

**空间复杂度**

KD-Tree存储在数组`kdtree`中，每个结点的struct需要存储18个int，因此其空间消耗为$O(18n)$，原始结点存储在`node`数组中，其大小也为$O(5n)$，除此以外，建树的递归实例个数应等于kd树的结点个数，节点个数不大于2n，查询递归的递归实例个数应等于访问结点的个数，递归深度为$O(log(n))$。因此总的空间复杂度应该为$O(n+log(n)) = O(n)$

